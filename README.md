
# pixie

a 24bit image generating stack machine

example:
```lisp
80 60
;;;; ./x.pixie
#x00070F ; a stack initialization value
----
; ^ header declares image dimensions and initializes the stack by pushing a 
; (possibly empty) list of numbers onto it. a line of dashes signals the end of
; the header. if the list of initializers is empty, the dashed line must
; still be present.

; rotate initial value x bits through the color space (the x component of 
; the pixel coord)

;;;;; initial state ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; #0 #x00070F  ; accumulator with initial value
; #1 y coordinate
; #2 x coordinate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

add          ; add x and y

#0 load      ; copy value at #0 to top (#2)
swap         ; swap copy of acc for coord sum
rotl         ; rotate sum bits in copy of accumlator value
dup #0 store ; duplicate value then move the copy to address #0 (accumulator)

;;;;; final state ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; #0 new pixel stored for next iteration
; #1 new pixel consumed for display
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
```
generated by: `./pixie < x.pixie > x.ppm`
output:

![](https://raw.githubusercontent.com/jessrud/pixie/master/x.png)

#### other command line options:
you may optionally set the `PIXIE_DEBUG` environment variable to any value to 
print a debug trace of the first run of the program to stderr., which will look 
something like
```
 5 pixStack: 000000 000000 000001 000017 00070F
 8 opStack: [add] 000000 load swap rotl dup 000000 store
 4 pixStack: 000000 000001 000017 00070F
 8 opStack: add [000000] load swap rotl dup 000000 store
 5 pixStack: 000000 000000 000001 000017 00070F
 8 opStack: add 000000 [load] swap rotl dup 000000 store
 5 pixStack: 00070F 000000 000001 000017 00070F
 8 opStack: add 000000 load [swap] rotl dup 000000 store
 ... 
```
with the top of the pixel stack on the left, and the previously executed
instruction `[bracketed]`.

### syntax
#### header
on the first line of the program you must specify the width and height of the program 
respectively as decimals.

like:
```
800 600
```
#### optional initialization values
following the header, you are allowed to enter a list of integer literals that 
will be pushed ontothe stack when the program starts. The values closer to the 
bottom of this list will be closer to thetop of the stack. example:
```
#xFF0000 ; a red pixel
#x00FF00 ; a green pixel
#x0000FF ; a blue pixel
----
```
note that the initialization sequence is terminated by a line consisting of 
dashes. Even if you provide zero initial values, you must terminate this empty 
list with a dashed line. No other characters can be on this line.

#### the actual program
the body of the program is in a simple RPN notation, flowing from left to right, 
top to bottom. all instructions and value literals are seperated by whitespace, 
and comments begin with a `;` and terminate at the end of the line they are on, 
or the end of the file, whichever comes first.

Literal integer values expressed as `#123` (decimal) `#b0101` (binary), and 
`#xAE987F` (hexidecimal) are interpreted as push instructions that add the value
they represent to the top of the stack.

Aside from integral and bitwise arithmetic operators, there are also `store` and
`load` instructions that let you address memory at arbitrary positions in the 
stack.

currently implemented instructions:

### nullary

* noop (0)  - does nothing
* rand (+1) - pushes a random pixel onto the top of the stack

### unary

* pop (-1) - discards top element on stack
* dup (+1) - pushes a duplicated of the top element to the stack
* load (0) - replaces address at top of the stack with the value
             at that address. works with address higher than
             the top of the stack (from 0 to 999)

### binary
* rotr (-1) - consumes a bit count (n), and rotates the bits in the pixel just 
              below the bit count (n) places to the right, wrapping them the 
              left most bit on overflow.
* rotl  (-1) - same as rotr, but the opposite direction.
* and   (-1) - bitwise and
* or    (-1) - bitwise or
* add   (-1) - addition; overflow is truncated
* sub   (-1) - subtraction
* mul   (-1) - multiplication
* div   (-1) - integer division
* swap  (0)  - swap top two elements
* store (-2) - consumes the address on the top of the stack and moves the value
               below it to that address.

